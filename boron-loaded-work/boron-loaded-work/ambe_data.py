import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib as mpl
from matplotlib import cm
import matplotlib.pyplot as plt
from gaussian import gauss_exp_fit
from matplotlib.lines import Line2D
from scipy.optimize import curve_fit
from scipy.signal import find_peaks, peak_prominences



sns.set_theme()
sns.set_style('ticks')

#am241 = 649 # for EJ-274

#-------------------------------------------------
#
#-------------------------------------------------
am241 = 366.90276397205605 # Am241 photopeak channel that is printed out
                           # when running the gamma_data.py

def PlotPSDvsEnergy(long,data):
    """
    long -- ENERGY column from the csv file generated by CoMPASS
    data -- an array of PSD values

    output -- the PSD vs. light histogram
    """
    fig,ax = plt.subplots(figsize=(4,3))

    nbins = 500

    plt.hist2d(long/am241,data,bins=(nbins,nbins),range=([0,np.max(long/am241)],[0,1]),cmin=1,cmap=cm.jet,norm=mpl.colors.LogNorm())
    plt.xlabel('Relative Light Yield ($^{241}$Am 59.5 keV e$^-$)')
    plt.ylabel('PSD Paramter')

    ax.set_xticks([0,1,2,3,4,5,6])
    ax.set_xticks([0.5,1.5,2.5,3.5,4.5,5.5],minor=True)
    ax.set_yticks([0.1,0.3,0.5,0.7,0.9],minor=True)

    ax.tick_params(axis='x', direction='in',top=True)
    ax.tick_params(axis='x', which='minor',direction='in',top=True)
    ax.tick_params(axis='y', direction='in',right=True)
    ax.tick_params(axis='x', which='minor',direction='in',right=True)
    ax.tick_params(axis='y', which='minor',direction='in',right=True)
    plt.ylim(0,0.5)
    plt.xlim(0,6)
    plt.colorbar()
    plt.savefig("plots/PSD_plot.png",dpi=300,bbox_inches='tight')
    plt.close()

def PlotTimevsEnergy(long,data):
    """
    long -- ENERGY column from the csv file generated by CoMPASS
    data -- an array of time values

    output 1 -- the time vs. light histogram
    output 2 -- centroid location versus time
    """
    fig,ax = plt.subplots(figsize=(4,3))
    data = (data/1e12)/3600
    nbins = 300
    matrix = plt.hist2d(long/am241,data,bins=(nbins,nbins),range=([0,np.max(long/am241)],[0,np.max(data)]),cmin=1,cmap=cm.jet,norm=mpl.colors.LogNorm())[0]
    # Matrix is (500,500) (long, time) data set
    plt.xlabel('Relative Light Yield ($^{241}$Am 59.5 keV e$^-$)')
    plt.ylabel('Time (hours)')

    ax.set_xticks([0,1,2,3,4,5,6])
    ax.set_xticks([0.5,1.5,2.5,3.5,4.5,5.5],minor=True)
    ax.set_yticks([5,15,25,35,45,55,65],minor=True)

    ax.tick_params(axis='x', direction='in',top=True)
    ax.tick_params(axis='x', which='minor',direction='in',top=True)
    ax.tick_params(axis='y', direction='in',right=True)
    ax.tick_params(axis='x', which='minor',direction='in',right=True)
    ax.tick_params(axis='y', which='minor',direction='in',right=True)

    plt.xlim(0,6)
    plt.colorbar()
    plt.savefig("plots/time_plot.png",dpi=300,bbox_inches='tight')
    plt.close()

    # I'll need to apply cuts along the time domain

    centroids = []
    cut = np.arange(0,max(data)-3,3)
    stop = np.arange(3,max(data),3)

    nbins = 500

    fig,ax = plt.subplots(figsize=(6,4))
    # Loop through the coincidence collect and capture the centroid peak every
    # 3 hours by applying a Gaussian + exp bkgrnd fit and taking the mean
    for i in range(len(cut)):
        long0 = [long[k]/am241 for k in range(len(data)) if cut[i] <= data[k] <= stop[i]]
        long1 = [x for x in long0 if 0.7 <= x]

        ldata, lbins = np.histogram(long1,nbins) #; lbins = lbins[:-1]

        params = [600,1.7,0.4,1e4,1e-3]

        x = np.array([(lbins[i]+lbins[i+1])/2 for i in range(len(lbins)-1)])

        g,u,s = gauss_exp_fit(x,ldata,params)
        centroids.append(u)

    # convert from rel. light units to keVee
    centroids = 59.5*np.array(centroids)
    centers = np.arange(1.5,max(data)-1.5,3)
    plt.errorbar(centers,centroids,fmt="-s",xerr=1.5,capsize=5,linewidth=0.8)

    ax.set_xticks(np.arange(5,70,5),minor=True)
    ax.set_yticks(np.arange(86.25,90.25,0.5),minor=True)
    plt.ylim(86,89.5)

    plt.xlabel("Time (hours)") ; plt.ylabel("Neutron capture centroid (keVee)")#plt.ylabel("Neutron capture centroid ($^{241}$Am 59.5 keV e$^-$)")

    ax.tick_params(axis='x', direction='in',top=True)
    ax.tick_params(axis='x', which='minor',direction='in',top=True)
    ax.tick_params(axis='y', direction='in',right=True)
    ax.tick_params(axis='x', which='minor',direction='in',right=True)
    ax.tick_params(axis='y', which='minor',direction='in',right=True)

    plt.savefig("plots/centroid-vs-time.png",dpi=300,bbox_inches='tight')
    u = np.average(centroids)
    print(" ---------------- Light Yield Data ------------------")
    print(" Centroid:                {:.3f} Rel. 59.5 keV | {:.3f} keVee".format(u, u*59.5))
    print(" Uncertainty in centroid: {:.3f} | {:.3f} keVee".format(np.array(centroids).std(),59.5*np.array(centroids).std()))
    print(" Drift over time (%):     {:.2f}".format(100*abs(centroids[0]-centroids[-1])/centroids[0]))



##------------------------------------------------------------------------
## 1. Read in the data
##------------------------------------------------------------------------
def ambe_data(param):
    """
    param is either house_ or whatever you'd like to call the dataset without
    the parffin wax present.
    """
    # Read in the data and calculate the PSD
    path = "2022_04_01_AFITB10JJM_AmBe_BisBox"

    df = pd.read_csv(path+"/UNFILTERED/AmBe.csv" , sep = ';')

    long = df["ENERGY"] ; short = df["ENERGYSHORT"]
    PSD = (long - short) / long

    ## cut out the insanely high low channel counts and saturation
    ## also ignore PSD < 0 values
    long = np.array([long[i] for i in range(len(long)) if PSD[i] > 0])
    PSD = np.array([x for x in PSD if x > 0])
    ## providing a lower and upper bounds to the data set. This gets rid of
    ## saturation events and noise in the lower channels

    PlotPSDvsEnergy(long,PSD,param)

from coincidence import generate_coincidence_data

def coincidence_data(param):
    ##------------------------------------------------------------------------
    ## Step 1. Generate the coincidence data if not done so, param = True
    ##------------------------------------------------------------------------
    if param:
        generate_coincidence_data()
    ##------------------------------------------------------------------------
    ## Step 2. Load the coincidence data, generate PSD array
    ##------------------------------------------------------------------------
    ch02 = np.load("ch02.npy") ; ch04 = np.load("ch04.npy")

    long = np.concatenate((ch02[:,1],ch04[:,1]))
    short = np.concatenate((ch02[:,2],ch04[:,2]))

    time = np.concatenate((ch02[:,0],ch04[:,0]))

    PSD = (long - short) / long
    ##------------------------------------------------------------------------
    ## Step 3. Only include events with PSD > 0
    ##------------------------------------------------------------------------
    long = np.array([long[i] for i in range(len(long)) if PSD[i] > 0])
    time = np.array([time[i] for i in range(len(time)) if PSD[i] > 0])
    PSD = np.array([x for x in PSD if x > 0])
    ##------------------------------------------------------------------------
    ## Step 4. Generate the PSD vs. Light histogram plot and the Time vs. Light
    ##         histogram plot
    ##------------------------------------------------------------------------
    PlotPSDvsEnergy(long,PSD)
    PlotTimevsEnergy(long,time)
    ##------------------------------------------------------------------------
    ## Step 5. Plot the signal with a Gaussian + exp bkgrnd fit
    ##------------------------------------------------------------------------
    long = long/am241
    long1 = np.array([x for x in long if 0.7 <= x])
    nbins = 500
    ldata,lbins = np.histogram(long1,nbins) #; lbins = lbins[:-1]

    fig,ax = plt.subplots(figsize=(4,3))

    params = [8000,1.7,0.4,1e4,1e-3]
    x = np.array([(lbins[i]+lbins[i+1])/2 for i in range(len(lbins)-1)])
    g,u,s = gauss_exp_fit(x,ldata,params)

    print("\n Centroid Value of Coincidence Signal: {:.3f} +/- 3%".format(u))

    plt.hist(long,nbins,histtype='step')
    plt.plot(x,g,color='r',linewidth=0.85)
    plt.ylabel("Counts") ; plt.xlabel("Relative Light Yield ($^{241}$Am 59.5 keV e$^-$)")
    plt.xlim(0,6)

    ax.set_yticks(np.arange(1000,10000,2000),minor=True)
    ax.set_xticks([0.5,1.5,2.5,3.5,4.5,5.5],minor=True)
    plt.ylim(0,8e3)
    plt.legend(["Eq. 2 Best Fit", "Signal"])
    ax.tick_params(axis='x', direction='in',top=True)
    ax.tick_params(axis='x', which='minor',direction='in',top=True)
    ax.tick_params(axis='y', direction='in',right=True)
    ax.tick_params(axis='x', which='minor',direction='in',right=True)
    ax.tick_params(axis='y', which='minor',direction='in',right=True)

    plt.savefig("plots/coincidence-signal.png",dpi=300,bbox_inches='tight')






#ambe_data("bisbox")
coincidence_data(False)
